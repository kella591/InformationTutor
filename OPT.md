# 动态规划
## 步骤
1. 确定最优解的要求
2. 确定下标、内容的含义
3. 划分子问题
4. 写出动态规划方程
5. 确定循环重数、层次、范围
6. 确定初始化值及解的生成方式

## 类型

### 单序列/线性动态规划
一维状态转移方程，f[i] 表示i状态时的最优解，子问题为所有下标j<i并满足限制的f[j]，f[i]=max(f[j]+转移代价）

#### 例程: 最长不下降子序列
* f[i]：以a[i]结尾的最长不下降子序列长度
* 子问题：所有下标j<i且a[j]<a[i]的f[j]
* 状态转移方程：f[1]:=1; f[i]:=max(f[j]+1)
* 目标：f[n]
```
for i:=1 to n do 
  for j:=1 to i-1 do 
    if a[i]>=a[j] then 
      f[i]=max(f[i],f[j]+1);
ans:=f[n];
```
#### 例程：最大连续子序列和
```
f[1]:=a[1];
for i:=1 to n do 
begin
    f[i]:=max(f[i-1]+a[i],a[i]);
    ans:=max(ans,f[i]);
end;
```

### 多序列动态规划
n维状态转移方程，f[i1,i2...in] 表示各个序列在i1,i2,...in状态时的最优解，子问题为状态回退一步时的最优解

#### 例程：最长公共子序列
* f[i,j]: a序列到a[i]为止，b序列到b[j]为止的最长公共子序列
* 子问题：a[i]=b[j]时的f[i-1,j-1]；a[i]<>b[j]时的f[i-1,j],f[i,j-1]——两个序列的最后一位算不算数
* 状态转移方程：f[0,0]:=0; f[i,j]:=max(f[i-1,j-1]+1(a[i]=b[j]),(f[i-1,j],f[i,j-1])(a[i]<>b[j]))
* 目标：f[n,m]
```
for i:=1 to n do 
  for j:= 1 to m do 
    begin
      if (a[i]=b[j]) then f[i,j]:=f[i-1,j-1]+1;
      f[i,j]:=max(f[i,j],f[i-1,j],f[i,j-1]);
    end;
ans:=f[n,m]
```

#### 例程：字符串编辑距离
给定A串和B串，有删除一个字符、插入一个字符、改变一个字符三种操作，求A变到B的最少操作次数。
```
for i:=1 to n do f[i][0]=i;
for i:=1 to m do f[0][i]=i;
for i:=1 to n do 
  for j:= 1 to m do 
    if (a[i]=b[j]) then f[i,j]:=f[i-1,j-1];
    else f[i,j]:=min(f[i-1,j-1],f[i-1,j],f[i,j-1])+1;
ans:=f[n,m];
```

### 区间型动态规划
二维状态转移方程，f[i,j]表示第i位到第j位区间的最优解，子问题为区间长度小于j-i+1时的最优解，从k处二分，f[i,j]=max(f[i,k]+f[k+1,j]+转移代价)
#### 例程：合并石子
### 划分型动态规划
二维状态转移方程，f[i,j]表示
#### 例程：乘积最大
### 棋盘型动态规划


### 背包问题
详细讲解可参阅教程

* 01背包
```
for i:=1 to n do 
  for j:= w downto a[i] do 
        f[j]=max(f[j],f[j-a[i]]+val[i]);
```
* 多维01背包
* 多重背包
* 



