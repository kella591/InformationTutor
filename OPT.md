# 动态规划
## 步骤
1. 确定最优解的要求
2. 确定下标、内容的含义
3. 划分子问题
4. 写出动态规划方程
5. 确定循环重数、层次、范围
6. 确定初始化值及解的生成方式

## 注意事项
1. 初始化
2. 循环次序
3. 预处理
4. 哪个是答案

## 类型

### 单序列/线性动态规划
一维状态转移方程，f[i] 表示i状态时的最优解，子问题为所有下标j<i并满足限制的f[j]，f[i]=max(f[j]+转移代价）

#### 例程: 最长不下降子序列
* f[i]：以a[i]结尾的最长不下降子序列长度
* 子问题：所有下标j<i且a[j]<a[i]的f[j]
* 状态转移方程：f[1]:=1; f[i]:=max(f[j]+1)
* 目标：f[n]
```
for i:=1 to n do 
  for j:=1 to i-1 do 
    if a[i]>=a[j] then 
      f[i]=max(f[i],f[j]+1);
ans:=f[n];
```
#### 例程：最大连续子序列和
```
f[1]:=a[1];
for i:=1 to n do 
begin
    f[i]:=max(f[i-1]+a[i],a[i]);
    ans:=max(ans,f[i]);
end;
```
***
### 多序列动态规划
n维状态转移方程，f[i1,i2...in] 表示各个序列在i1,i2,...in状态时的最优解，子问题为状态回退一步时的最优解

#### 例程：最长公共子序列
* f[i,j]: a序列到a[i]为止，b序列到b[j]为止的最长公共子序列
* 子问题：a[i]=b[j]时的f[i-1,j-1]；a[i]<>b[j]时的f[i-1,j],f[i,j-1]——两个序列的最后一位算不算数
* 状态转移方程：f[0,0]:=0; f[i,j]:=max(f[i-1,j-1]+1(a[i]=b[j]),(f[i-1,j],f[i,j-1])(a[i]<>b[j]))
* 目标：f[n,m]
```
for i:=1 to n do 
  for j:= 1 to m do 
    begin
      if (a[i]=b[j]) then f[i,j]:=f[i-,j-1]+1;
      f[i,j]:=max(f[i,j],f[i-1,j],f[i,j-1]);
    end;
ans:=f[n,m]
```

#### 例程：字符串编辑距离
给定A串和B串，有删除一个字符、插入一个字符、改变一个字符三种操作，求A变到B的最少操作次数。
```
for i:=1 to n do f[i][0]=i;
for i:=1 to m do f[0][i]=i;
for i:=1 to n do 
  for j:= 1 to m do 
    if (a[i]=b[j]) then f[i,j]:=f[i-1,j-1];
    else f[i,j]:=min(f[i-1,j-1],f[i-1,j],f[i,j-1])+1;
ans:=f[n,m];
```
***
### 区间型动态规划
二维状态转移方程，f[i,j]表示第i位到第j位区间的最优解，子问题为区间长度小于j-i+1时的最优解，从k处二分，f[i,j]=max(f[i,k]+f[k+1,j]+转移代价)。此类型的题往往要做预处理。
#### 例程：合并石子
在一个圆形操场的四周摆放着n堆石子。现要将石子有次序地合并成一堆。规定每次只能选择相邻的两堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。试设计一个算法，计算出将n堆石子合并成一堆的最大得分。
```
for i:=1 to n do f[i,i]:=0;
s[0]:=0;
for i:=1 to n do s[i]:=s[i-1]+a[i];
for k:=2 to n do 
  for i:=1 to n-k+1 do 
    for j:=i to i+k-1 do
      f[i,i+k-1]=max(f[i,i+k-1], f[i,j]+f[j+1,i+k-1]+s[i+k-1]-s[i-1]);
ans:=f[1,n];
```
#### *例程：能量项链
***
### 划分型动态规划
二维状态转移方程，f[i,j]表示前i位分成j份/前i个资源分给j个目标的最优解，子问题为前k<i位分成j-1份时的最优解，f[i,j]=max(f[k,j-1]+a[k+1,i](转移代价))。此类型的题往往要做预处理。
#### 例程：乘积最大
设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大
```
for i:=1 to n do val(copy(s,1,i),f[i,0]);
for i:=2 to n do
  for j:=1 to k do
    for m:=1 to i-1 do
    begin
      val(copy(s,m+1,i-m),t);
      f[i,j]:=max(f[m,j-1]*t;,f[i,j]);
    end;
```
***
### 棋盘型动态规划
二维或多维状态转移方程，题目本身基于二维平面的路径问题，f[i,j]为走到i行j列时的最优解，子问题为上一步的最优解，f[i,j]=max(f[i-1,j],f[i,j-1])+转移代价
*在普通递推的基础上可能加入可重复路径，此时需要多维状态压缩

#### 例程：移动路线
m行n列的方格矩阵，将每个方格用坐标表示，行坐标从下到上依次递增，列坐标从左至右依次递增，左下角方格的坐标为(1,1)，则右上角方格的坐标为(m,n)。移动时只能向右走或向上走，求从左下角走到右上角一共有几种可能路线
```
f[1,1]=1;
for i:=2 to n do f[1,i]:=f[1,i-1];
for i:=2 to m do f[i,1]:=f[i-1,1];
for i:= 2 to m do 
  for j:=2 to n do 
    f[i,j]:=f[i-1,j]+f[i,j-1];
```
#### 例程：三取方格数
设有N*N的方格图，我们将其中的某些方格填入正整数，而其他的方格中放入0。
某人从图得左上角出发，可以向下走，也可以向右走，直到到达右下角。
在走过的路上，他取走了方格中的数。（取走后方格中数字变为0）
此人从左上角到右下角共走3次，试找出3条路径，使得取得的数总和最大。
>经典问题，f[x][i][j][k]表示第x步三个人分别在第i行，第j行，第k行时所能达到最大值，i,j,k顺推逆推皆可，因为用到的是f[x-1][][][]；初值为f[1][1][1][1]=a[1][1]；
```
f[1][1][1][1]=a[1][1];
    for(int x=1;x<=2*n-1;x++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                for(int k=1;k<=n;k++)
                {
                    int i1=x-i+1;int j1=x-j+1;int k1=x-k+1;
                    if(i1<0||j1<0||k1<0)    continue;
                    f[x][i][j][k]=max1(f[x-1][i-1][j][k],f[x-1][i][j-1][k],
                                      f[x-1][i][j][k-1],f[x-1][i-1][j-1][k],
                                      f[x-1][i-1][j][k-1],f[x-1][i][j-1][k-1],
                                      f[x-1][i-1][j-1][k-1],f[x-1][i][j][k])+a[i][i1]+a[j][j1]+a[k][k1];//最后一个状态别忘了x也要-1
                    //处理多次走到同一个点的情况
                    if(i==j)
                        f[x][i][j][k]-=a[i][i1];
                    if(j==k)
                        f[x][i][j][k]-=a[j][j1];
                    if(i==k)
                        f[x][i][j][k]-=a[i][i1];
                    if(i==k&&k==j)
                        f[x][i][j][k]+=a[i][i1];
```
***
### 背包问题
详细讲解可参阅教程

* 01背包
```
for i:=1 to n do 
  for j:= w downto a[i] do 
  if(f[j-a[i]]<>0 or j=a[i])//需要求所有可能组合成的值时使用
        f[j]=max(f[j],f[j-a[i]]+val[i]);
```
* 完全背包 每个物品可以放无数次
```
for i:=1 to n do 
    for j:= a[i] to w do //注意这里的改动
        f[j]=max(f[j],f[j-a[i]]+val[i]);
```
* 多维01背包
* 多重背包
* 组合背包



